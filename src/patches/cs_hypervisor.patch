diff --git a/src/arch/riscv/cpu.c b/src/arch/riscv/cpu.c
index 4bdfb11..d8ccc93 100644
--- a/src/arch/riscv/cpu.c
+++ b/src/arch/riscv/cpu.c
@@ -8,6 +8,8 @@
 #include <arch/sbi.h>
 #include <platform.h>
 
+#include <crosscon_soc.h>
+
 cpuid_t CPU_MASTER __attribute__((section(".data")));
 
 /* Perform architecture dependent cpu cores initializations */
@@ -30,6 +32,20 @@ void cpu_arch_init(cpuid_t cpuid, paddr_t load_addr)
     spmp_init(&cpu()->arch.spmp_hyp, PRIV_HYP);
     spmp_set_active(&cpu()->arch.spmp_hyp, true);
 #endif
+
+    // CROSSCON SoC specific
+    // TODO: This is specific for the platform. Find a better place for this.
+
+    // Allow both VM1 (domain 0) to access UART 0 and VM2 (domain 1) to access UART 1.
+    set_pg_rspace_entry((unsigned int *) APB_SUB_PG_CSR_ADR, 0, 0, UART_0_BASE_ADR, UART_0_BASE_ADR + 0xfffff, true, true);
+    set_pg_rspace_entry((unsigned int *) APB_SUB_PG_CSR_ADR, 2, 0, UART_1_BASE_ADR, UART_1_BASE_ADR + 0xfffff, true, true);
+    set_pg_rspace_entry((unsigned int *) APB_SUB_PG_CSR_ADR, 4, 1, UART_0_BASE_ADR, UART_0_BASE_ADR + 0xfffff, true, true);
+    set_pg_rspace_entry((unsigned int *) APB_SUB_PG_CSR_ADR, 6, 1, UART_1_BASE_ADR, UART_1_BASE_ADR + 0xfffff, true, true);
+
+    // TODO: Needs to be dynamically set.
+    // PG's QMEM PG so that AES-GCM can access VM1's and VM2's memory over AHB bus.
+    set_pg_rspace_entry((unsigned int *) QMEM_PG_CSR_ADR, 0, 0, 0x60000, 0x70000, true, true);
+    set_pg_rspace_entry((unsigned int *) QMEM_PG_CSR_ADR, 2, 1, 0x70000, 0x80000, true, true);
 }
 
 void cpu_arch_standby(void)
diff --git a/src/arch/riscv/interrupts.c b/src/arch/riscv/interrupts.c
index 7d0aba2..77907c1 100644
--- a/src/arch/riscv/interrupts.c
+++ b/src/arch/riscv/interrupts.c
@@ -16,6 +16,8 @@
 #include <fences.h>
 #include <arch/aclint.h>
 
+#include <crosscon_soc.h>
+
 #define USE_ACLINT_IPI() (ACLINT_PRESENT() && (IRQC != AIA))
 
 irqid_t irqc_timer_int_id;
@@ -82,6 +84,11 @@ void interrupts_arch_enable(irqid_t int_id, bool en)
 
 void interrupts_arch_handle(void)
 {
+    // CROSSCON SoC specific: Set DID to 0.
+    uint32_t *pg_add_sig_drv = (uint32_t*) PG_ADD_SIG_DRV_ADR;
+    uint32_t prev_did = pg_add_sig_drv[0];
+    pg_add_sig_drv[0] = 0;
+
 #if (IRQC == AIA)
     unsigned long stopi = csrs_stopi_read();
 
@@ -127,6 +134,8 @@ void interrupts_arch_handle(void)
             break;
     }
 #endif
+
+    pg_add_sig_drv[0] = prev_did;
 }
 
 bool interrupts_arch_check(irqid_t int_id)
diff --git a/src/arch/riscv/objects.mk b/src/arch/riscv/objects.mk
index 4684074..b639765 100644
--- a/src/arch/riscv/objects.mk
+++ b/src/arch/riscv/objects.mk
@@ -13,3 +13,4 @@ cpu-objs-y+=cache.o
 cpu-objs-y+=aclint.o
 cpu-objs-y+=vfp.o
 cpu-objs-y+=timer.o
+cpu-objs-y+=crosscon_soc.o
diff --git a/src/arch/riscv/spmp/boot.S b/src/arch/riscv/spmp/boot.S
index 5fe72f1..f65f4b7 100644
--- a/src/arch/riscv/spmp/boot.S
+++ b/src/arch/riscv/spmp/boot.S
@@ -15,8 +15,8 @@ boot_arch:
     /* Set sscratch to point to cpu struct and clear it*/
     la  t0, _image_end
     li  t1, CPU_SIZE
-    mul t1, t1, a0
-    add a3, t0, t1
+    mul t2, t1, a0
+    add a3, t0, t2
     csrw sscratch, a3
     add a4, a3, t1
 	call boot_clear
diff --git a/src/arch/riscv/sync_exceptions.c b/src/arch/riscv/sync_exceptions.c
index 84f73ab..c18c3c1 100644
--- a/src/arch/riscv/sync_exceptions.c
+++ b/src/arch/riscv/sync_exceptions.c
@@ -11,6 +11,8 @@
 #include <arch/instructions.h>
 #include <arch/fences.h>
 
+#include <crosscon_soc.h>
+
 static void internal_exception_handler(unsigned long gprs[])
 {
     for (int i = 0; i < 31; i++) {
@@ -90,59 +92,10 @@ static inline bool is_pseudo_ins(long unsigned int ins)
 
 static size_t guest_page_fault_handler(void)
 {
-    vaddr_t addr = (csrs_htval_read() << 2) | (csrs_stval_read() & 0x3);
-
-    emul_handler_t handler = vm_emul_get_mem(cpu()->vcpu->vm, addr);
-    if (handler != NULL) {
-        unsigned long ins = csrs_htinst_read();
-        size_t ins_size;
-        if (ins == 0) {
-            /**
-             * If htinst does not provide information about the trap, we must read the instruction
-             * from the guest's memory manually.
-             */
-            vaddr_t ins_addr = csrs_sepc_read();
-            ins = read_ins(ins_addr);
-            ins_size = INS_SIZE(ins);
-        } else if (is_pseudo_ins((uint32_t)ins)) {
-            // TODO: we should reinject this in the guest as a fault access
-            ERROR("fault on 1st stage page table walk");
-        } else {
-            /**
-             * If htinst is valid and is not a pseudo isntruction make sure the opcode is valid
-             * even if it was a compressed instruction, but before save the real instruction size.
-             */
-            ins_size = TINST_INS_SIZE(ins);
-            ins = ins | 0x2;
-        }
-
-        struct emul_access emul;
-        if (!ins_ldst_decode(ins, &emul)) {
-            ERROR("cant decode ld/st instruction");
-        }
-        emul.addr = addr;
+    // Because BA51-H does not have an MMU, guest-page fault can only be raised by hSPMP.
 
-        /**
-         * TODO: check if the access is aligned. If not, inject an exception in the vm.
-         */
+    ERROR("hSPMP access violation at address 0x%lx. Halting execution.", csrs_sepc_read())
 
-        if (handler(&emul)) {
-            return ins_size;
-        } else {
-            ERROR("emulation handler failed (0x%x at 0x%x)", addr, csrs_sepc_read());
-        }
-    } else {
-        struct vcpu* vcpu = cpu()->vcpu;
-        WARNING("no emulation handler for abort(0x%x at 0x%x)\n", addr, csrs_sepc_read());
-        list_foreach (vcpu->vm->mem_abort_list, struct hndl_mem_abort_node, node) {
-            mem_abort_handler_t sdeehandler = node->hndl_mem_abort.handler;
-            if (sdeehandler != NULL) {
-                if (sdeehandler(vcpu, addr)) {
-                    ERROR("handler abort failed (0x%x)", addr);
-                }
-            }
-        }
-    }
     return 0;
 }
 
@@ -185,6 +138,11 @@ static const size_t sync_handler_table_size = sizeof(sync_handler_table) / sizeo
 void sync_exception_handler(void);
 void sync_exception_handler(void)
 {
+    // CROSSCON SoC specific: Set the DID to 0.
+    uint32_t *pg_add_sig_drv = (uint32_t*) PG_ADD_SIG_DRV_ADR;
+    uint32_t prev_did = pg_add_sig_drv[0];
+    pg_add_sig_drv[0] = 0;
+
     size_t pc_step = 0;
     unsigned long _scause = csrs_scause_read();
     struct vcpu* calling_vcpu = cpu()->vcpu;
@@ -207,4 +165,6 @@ void sync_exception_handler(void)
     if (vcpu_arch_is_on(cpu()->vcpu) && !cpu()->vcpu->active) {
         cpu_standby();
     }
+
+    pg_add_sig_drv[0] = prev_did;
 }
diff --git a/src/arch/riscv/vm.c b/src/arch/riscv/vm.c
index 7dbc935..d4efc73 100644
--- a/src/arch/riscv/vm.c
+++ b/src/arch/riscv/vm.c
@@ -11,6 +11,8 @@
 #include <string.h>
 #include <config.h>
 
+#include <crosscon_soc.h>
+
 void vm_arch_init(struct vm* vm, const struct vm_config* vm_config)
 {
 #ifdef MEM_PROT_MMU
@@ -133,6 +135,12 @@ void vcpu_restore_state(struct vcpu* vcpu)
     spmp_set_active(&vcpu->arch.spmp, true);
     spmp_restore(&vcpu->arch.spmp);
 #endif
+
+    // CROSSCON SoC specific
+    // TODO: This is specific for the platform. Find a better place for this.
+
+    uint32_t *pg_add_sig_drv = (uint32_t*) PG_ADD_SIG_DRV_ADR;
+    pg_add_sig_drv[0] = vcpu->vm->id;
 }
 
 void vcpu_save_state(struct vcpu* vcpu)
diff --git a/src/platform/crosscon_soc/platform.mk b/src/platform/crosscon_soc/platform.mk
index db18893..92d5699 100644
--- a/src/platform/crosscon_soc/platform.mk
+++ b/src/platform/crosscon_soc/platform.mk
@@ -17,6 +17,7 @@ platform_description:=crosscon-soc_desc.c
 arch_mem_prot:=mpu
 
 platform-cppflags =-DIPIC=$(IPIC)
+platform-cppflags +=-std=c11
 platform-cflags =
 platform-asflags =
 platform-ldflags =
