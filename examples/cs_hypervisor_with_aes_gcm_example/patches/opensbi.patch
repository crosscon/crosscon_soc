diff --git a/include/sbi_utils/serial/beyond_cs_uart.h b/include/sbi_utils/serial/beyond_cs_uart.h
new file mode 100644
index 0000000..0dc11a6
--- /dev/null
+++ b/include/sbi_utils/serial/beyond_cs_uart.h
@@ -0,0 +1,1180 @@
+/*******************************************************************
+ * Register definitions for
+ * ============================
+ * BA5x_BydAHBSOC, version: 1.0
+ *   peripheral
+ * UART
+ *   by 
+ * Beyond Semiconductor
+ * 
+ * Created by sdtool 
+ *   from sd/ba5x-byd-ahb-soc.sd.xml
+ *   on 2022-11-21 15:17:43.987569
+ *   using template src/templates/h/mmio.jinja
+ *******************************************************************
+ */
+
+#ifndef __regaccess_Beyond_Semiconductor_BA5x_BydAHBSOC_1_0_UART__
+#define __regaccess_Beyond_Semiconductor_BA5x_BydAHBSOC_1_0_UART__
+
+#include <sbi/sbi_console.h>
+
+#include "rvrac.h"
+
+/*------------------------------------------------------------------
+ * register RBR @ 0x10700000
+ *   (read-only 8-bit memory mapped register)
+ *   "Receiver buffer register.
+This register contains the (oldest) byte received.
+If FIFO is used, each new read will return the next byte.
+This register is only accessible when LCR.DLAB=0."
+ *------------------------------------------------------------------
+ */
+#define UART_RBR 0x10700000
+#define UART_RBR_PTR (uint8_t *)(0x10700000)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rbr(void)
+{
+	return REG8(UART_RBR);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register THR @ 0x10700000
+ *   (write-only 8-bit memory mapped register)
+ *   "Transmitter holding register.
+This register is only accessible when LCR.DLAB=0."
+ *------------------------------------------------------------------
+ */
+#define UART_THR 0x10700000
+#define UART_THR_PTR (uint8_t *)(0x10700000)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_thr(void)
+{
+	return REG8(UART_THR);
+}
+
+static inline void uart_write_thr(uint8_t value)
+{
+	REG8(UART_THR) = value;
+}
+
+static inline uint8_t uart_rw_thr(uint8_t value)
+{
+	return rw_reg8(UART_THR_PTR, value);
+}
+
+static inline uint8_t uart_set_thr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_THR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_thr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_THR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register DLL @ 0x10700000
+ *   (read-write 8-bit memory mapped register)
+ *   "DLL (alias LSB-DL): divisor latch LSB. Defines bits [7:0] of divisor.
+This register is accessible only when LCR.DLAB=1."
+ *------------------------------------------------------------------
+ */
+#define UART_DLL 0x10700000
+#define UART_DLL_PTR (uint8_t *)(0x10700000)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_dll(void)
+{
+	return REG8(UART_DLL);
+}
+
+static inline void uart_write_dll(uint8_t value)
+{
+	REG8(UART_DLL) = value;
+}
+
+static inline uint8_t uart_rw_dll(uint8_t value)
+{
+	return rw_reg8(UART_DLL_PTR, value);
+}
+
+static inline uint8_t uart_set_dll(uint_csr32_t setmask)
+{
+	return set_reg8(UART_DLL_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_dll(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_DLL_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register IER @ 0x10700001
+ *   (read-write 8-bit memory mapped register)
+ *   "Interrupt enable register.
+This register is only accessible when LCR.DLAB=0."
+ *------------------------------------------------------------------
+ */
+#define UART_IER 0x10700001
+#define UART_IER_PTR (uint8_t *)(0x10700001)
+
+  /* Enable receiver data available interrupt.
+It also enables timeout interrupts in FIFO mode */ 
+  #define UART_IER_F_RDA_INT 0x00000001
+  #define UART_IER_F_RDA_INT_OFFSET 0
+
+  /* Enable transmitter holding register empty interrupt. */ 
+  #define UART_IER_F_THRE_INT 0x00000002
+  #define UART_IER_F_THRE_INT_OFFSET 1
+
+  /* Enable receiver line status interrupt. */ 
+  #define UART_IER_F_RLS_INT 0x00000004
+  #define UART_IER_F_RLS_INT_OFFSET 2
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_ier(void)
+{
+	return REG8(UART_IER);
+}
+
+static inline void uart_write_ier(uint8_t value)
+{
+	REG8(UART_IER) = value;
+}
+
+static inline uint8_t uart_rw_ier(uint8_t value)
+{
+	return rw_reg8(UART_IER_PTR, value);
+}
+
+static inline uint8_t uart_set_ier(uint_csr32_t setmask)
+{
+	return set_reg8(UART_IER_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_ier(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_IER_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register DLM @ 0x10700001
+ *   (read-write 8-bit memory mapped register)
+ *   "DLM (alias MSB-DL): Divisor latch MSB. Defines bits [15:8] of divisor.
+This register is accessible only when LCR.DLAB=1."
+ *------------------------------------------------------------------
+ */
+#define UART_DLM 0x10700001
+#define UART_DLM_PTR (uint8_t *)(0x10700001)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_dlm(void)
+{
+	return REG8(UART_DLM);
+}
+
+static inline void uart_write_dlm(uint8_t value)
+{
+	REG8(UART_DLM) = value;
+}
+
+static inline uint8_t uart_rw_dlm(uint8_t value)
+{
+	return rw_reg8(UART_DLM_PTR, value);
+}
+
+static inline uint8_t uart_set_dlm(uint_csr32_t setmask)
+{
+	return set_reg8(UART_DLM_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_dlm(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_DLM_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register IIR @ 0x10700002
+ *   (read-only 8-bit memory mapped register)
+ *   "Interrupt identification register"
+ *------------------------------------------------------------------
+ */
+#define UART_IIR 0x10700002
+#define UART_IIR_PTR (uint8_t *)(0x10700002)
+
+  /* Interrupt pending */ 
+  #define UART_IIR_F_IP 0x00000001
+  #define UART_IIR_F_IP_OFFSET 0
+
+    // there are UART interrupts pending
+    #define UART_IIR_F_IP_E_PENDING 0x0
+
+    // no pending UART interrupts.
+    #define UART_IIR_F_IP_E_NOT_PENDING 0x1
+
+  /* pending interrupt identification */ 
+  #define UART_IIR_F_PIID 0x0000000e
+  #define UART_IIR_F_PIID_OFFSET 1
+
+    // Modem status change interrupt pending
+    #define UART_IIR_F_PIID_E_MSC_IP 0x0
+
+    // Transmitter holding register empty interrupt pending.
+    #define UART_IIR_F_PIID_E_THRE_IP 0x1
+
+    // Receiver data ready interrupt pending.
+    #define UART_IIR_F_PIID_E_RDR_IP 0x2
+
+    // Line status change interrupt pending.
+    #define UART_IIR_F_PIID_E_LSC_IP 0x3
+
+    // Character timeout interrupt pending.
+    #define UART_IIR_F_PIID_E_CHR_TIMEOUT_IP 0x6
+
+  /* FIFOs enabled */ 
+  #define UART_IIR_F_FE 0x000000c0
+  #define UART_IIR_F_FE_OFFSET 6
+
+    // FIFOs are disabled.
+    #define UART_IIR_F_FE_E_DISABLED 0x0
+
+    // FIFOs are enabled.
+    #define UART_IIR_F_FE_E_ENABLED 0x3
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_iir(void)
+{
+	return REG8(UART_IIR);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register FCR @ 0x10700002
+ *   (write-only 8-bit memory mapped register)
+ *   "FIFO control register.
+This register is used to enable/clear FIFO, set FIFO trigger level, etc.
+This register is only accessible when LCR.DLAB=0."
+ *------------------------------------------------------------------
+ */
+#define UART_FCR 0x10700002
+#define UART_FCR_PTR (uint8_t *)(0x10700002)
+
+  /* Enable transmitter and receiver FIFOs. */ 
+  #define UART_FCR_F_FIFO_ENABLE 0x00000001
+  #define UART_FCR_F_FIFO_ENABLE_OFFSET 0
+
+  /* Receiver FIFO reset. Clears all bytes in receiver FIFO and resets FIFO level to 0.
+Shift register is not cleared. This bit is self-clearing. */ 
+  #define UART_FCR_F_RFR 0x00000002
+  #define UART_FCR_F_RFR_OFFSET 1
+
+  /* Transmitter FIFO reset. Clears all bytes in transmitter FIFO and resets FIFO level to 0.
+Shift register is not cleared. This bit is self-clearing. */ 
+  #define UART_FCR_F_TFR 0x00000004
+  #define UART_FCR_F_TFR_OFFSET 2
+
+  /* This field defines receiver FIFO interrupt trigger level.
+To set up trigger level FIFO needs to be enabled in FCR before trigger level can be set.
+(You can not enable FIFO and select trigger level with single write.) */ 
+  #define UART_FCR_F_RFTRIG 0x000000c0
+  #define UART_FCR_F_RFTRIG_OFFSET 6
+
+    // Trigger when FIFO contains at least byte.
+    #define UART_FCR_F_RFTRIG_E_TL1B 0x0
+
+    // Trigger when FIFO is at least 1/4 full.
+    #define UART_FCR_F_RFTRIG_E_TL_1_4 0x1
+
+    // Trigger when FIFO is at least 1/2 full.
+    #define UART_FCR_F_RFTRIG_E_TL_1_2 0x2
+
+    // Trigger when FIFO is at least 7/8 full.
+    #define UART_FCR_F_RFTRIG_E_TL_7_8 0x3
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_fcr(void)
+{
+	return REG8(UART_FCR);
+}
+
+static inline void uart_write_fcr(uint8_t value)
+{
+	REG8(UART_FCR) = value;
+}
+
+static inline uint8_t uart_rw_fcr(uint8_t value)
+{
+	return rw_reg8(UART_FCR_PTR, value);
+}
+
+static inline uint8_t uart_set_fcr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_FCR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_fcr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_FCR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register LCR @ 0x10700003
+ *   (read-write 8-bit memory mapped register)
+ *   "Line Control Register "
+ *------------------------------------------------------------------
+ */
+#define UART_LCR 0x10700003
+#define UART_LCR_PTR (uint8_t *)(0x10700003)
+
+  /* This field specified number of bits in each transmitted or received character. */ 
+  #define UART_LCR_F_BITS 0x00000003
+  #define UART_LCR_F_BITS_OFFSET 0
+
+    // characters are 5 bits long
+    #define UART_LCR_F_BITS_E_CHR5B 0x0
+
+    // characters are 6 bits long
+    #define UART_LCR_F_BITS_E_CHR6B 0x1
+
+    // characters are 7 bits long
+    #define UART_LCR_F_BITS_E_CHR7B 0x2
+
+    // characters are 8 bits long
+    #define UART_LCR_F_BITS_E_CHR8B 0x3
+
+  /* This filed specifies number of stop bits transmitter or received in each serial character. */ 
+  #define UART_LCR_F_STOP 0x00000004
+  #define UART_LCR_F_STOP_OFFSET 2
+
+    // Single stop bit.
+    #define UART_LCR_F_STOP_E_STOP_1 0x0
+
+    // One and half stop bit when 5 bit characters are used. 2 stop bits otherwise.
+    #define UART_LCR_F_STOP_E_STOP_MORE 0x1
+
+  /* This field defines if parity bit is generated/checked and how this is done, if enabled.. */ 
+  #define UART_LCR_F_PARITY 0x00000038
+  #define UART_LCR_F_PARITY_OFFSET 3
+
+    // Parity is disabled.
+    #define UART_LCR_F_PARITY_E_NO_PARITY 0x0
+
+    // Odd number of logic ones.
+    #define UART_LCR_F_PARITY_E_ODD_PARITY 0x1
+
+    // Even number of logic ones.
+    #define UART_LCR_F_PARITY_E_EVEN_PARITY 0x3
+
+    // High parity (stick). Parity bit is always 1.
+    #define UART_LCR_F_PARITY_E_HIGH_PARITY 0x5
+
+    // Low parity (stick). Parity bit is always 0.
+    #define UART_LCR_F_PARITY_E_LOW_PARITY 0x7
+
+  /* Break control bit. */ 
+  #define UART_LCR_F_BREAK 0x00000040
+  #define UART_LCR_F_BREAK_OFFSET 6
+
+    // Break signal disabled.
+    #define UART_LCR_F_BREAK_E_DISABLED 0x0
+
+    // Break signal enabled.
+    #define UART_LCR_F_BREAK_E_ENABLED 0x1
+
+  /* Divisor latch access bit. */ 
+  #define UART_LCR_F_DLAB 0x00000080
+  #define UART_LCR_F_DLAB_OFFSET 7
+
+    // Data control registers (RBR, THR and IER) are accessible. Divisor latches are shadowed.
+    #define UART_LCR_F_DLAB_E_DATA 0x0
+
+    // Divisor latches (DLL and DLM) are accessible. Data registers are shadowed.
+    #define UART_LCR_F_DLAB_E_DIVISOR 0x1
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_lcr(void)
+{
+	return REG8(UART_LCR);
+}
+
+static inline void uart_write_lcr(uint8_t value)
+{
+	REG8(UART_LCR) = value;
+}
+
+static inline uint8_t uart_rw_lcr(uint8_t value)
+{
+	return rw_reg8(UART_LCR_PTR, value);
+}
+
+static inline uint8_t uart_set_lcr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_LCR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_lcr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_LCR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register MCR @ 0x10700004
+ *   (read-write 8-bit memory mapped register)
+ *   "Modem Control Register"
+ *------------------------------------------------------------------
+ */
+#define UART_MCR 0x10700004
+#define UART_MCR_PTR (uint8_t *)(0x10700004)
+
+  /* This bit controls the Data Terminal Ready output.  */ 
+  #define UART_MCR_F_DTR 0x00000001
+  #define UART_MCR_F_DTR_OFFSET 0
+
+  /* This bit controls the Request To Send output.  */ 
+  #define UART_MCR_F_RTS 0x00000002
+  #define UART_MCR_F_RTS_OFFSET 1
+
+  /* This bit controls the Output 1 auxiliary used designated output.  */ 
+  #define UART_MCR_F_OUT1 0x00000004
+  #define UART_MCR_F_OUT1_OFFSET 2
+
+  /* This bit controls the Output 2 auxiliary used designated output.  */ 
+  #define UART_MCR_F_OUT2 0x00000008
+  #define UART_MCR_F_OUT2_OFFSET 3
+
+  /* This bit (when set) enables loopback mode operation of UART.  */ 
+  #define UART_MCR_F_LOOP 0x00000010
+  #define UART_MCR_F_LOOP_OFFSET 4
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_mcr(void)
+{
+	return REG8(UART_MCR);
+}
+
+static inline void uart_write_mcr(uint8_t value)
+{
+	REG8(UART_MCR) = value;
+}
+
+static inline uint8_t uart_rw_mcr(uint8_t value)
+{
+	return rw_reg8(UART_MCR_PTR, value);
+}
+
+static inline uint8_t uart_set_mcr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_MCR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_mcr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_MCR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register LSR @ 0x10700005
+ *   (read-write 8-bit memory mapped register)
+ *   "Line Status Register
+This register provides data transfer status.
+Although this register can be written, user is supposed to only read it."
+ *------------------------------------------------------------------
+ */
+#define UART_LSR 0x10700005
+#define UART_LSR_PTR (uint8_t *)(0x10700005)
+
+  /* Data Ready.
+This bit is set when incoming character has been received and is available in RBR of FIFO.
+It is reset, when all data has been read from RBR of FIFO. */ 
+  #define UART_LSR_F_DR 0x00000001
+  #define UART_LSR_F_DR_OFFSET 0
+
+  /* Overrun Error indicator bit.
+This bit is set if next character has been received before RBR has been read or if next character has been received when FIFO was already full. */ 
+  #define UART_LSR_F_OE 0x00000002
+  #define UART_LSR_F_OE_OFFSET 1
+
+  /* Parity Error Bit. It indicates current received character does not have correct even or odd parity.
+Bit is cleared whenever the LSR is read. */ 
+  #define UART_LSR_F_PE 0x00000004
+  #define UART_LSR_F_PE_OFFSET 2
+
+  /* Framing error bit. It indicates current received character did not have a valid stop bit.
+Bit is cleared whenever the LSR is read. */ 
+  #define UART_LSR_F_FE 0x00000008
+  #define UART_LSR_F_FE_OFFSET 3
+
+  /* Break Interrupt. */ 
+  #define UART_LSR_F_BI 0x00000010
+  #define UART_LSR_F_BI_OFFSET 4
+
+  /* Transmitter Holding Register Empty indicator.
+It indicates UART is ready to accept new character for transmission.
+This bit is cleared, when at least one byte is written to transmitter FIFO. */ 
+  #define UART_LSR_F_THRE 0x00000020
+  #define UART_LSR_F_THRE_OFFSET 5
+
+  /* Transmitter EMpTy indicator.
+It indicates both transmitter holding register (THR) and transmitter shift register (TSR) are empty.
+In FIFO mode this bit is set when FIFO and TSR are empty. */ 
+  #define UART_LSR_F_TEMT 0x00000040
+  #define UART_LSR_F_TEMT_OFFSET 6
+
+  /* Error In FIFO.
+In FIFO mode only this bit is set, when there is at least one parity error, framing error or break indication in the FIFO.
+Bit is cleared, when LSR is read, provided there are no further errors in FIFO. */ 
+  #define UART_LSR_F_EIF 0x00000080
+  #define UART_LSR_F_EIF_OFFSET 7
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_lsr(void)
+{
+	return REG8(UART_LSR);
+}
+
+static inline void uart_write_lsr(uint8_t value)
+{
+	REG8(UART_LSR) = value;
+}
+
+static inline uint8_t uart_rw_lsr(uint8_t value)
+{
+	return rw_reg8(UART_LSR_PTR, value);
+}
+
+static inline uint8_t uart_set_lsr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_LSR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_lsr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_LSR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register MSR @ 0x10700006
+ *   (read-write 8-bit memory mapped register)
+ *   "Modem Status Register
+This register provides status of the control lines from peripheral device."
+ *------------------------------------------------------------------
+ */
+#define UART_MSR 0x10700006
+#define UART_MSR_PTR (uint8_t *)(0x10700006)
+
+  /* Delta Clear To Send.
+Indicates CTS input has changed since it was last read.
+Reading this field resets it's value to 0. */ 
+  #define UART_MSR_F_DCTS 0x00000001
+  #define UART_MSR_F_DCTS_OFFSET 0
+
+  /* Delta Data Set Ready.
+Indicates DSR input has changed since it was last read.
+Reading this field resets it's value to 0. */ 
+  #define UART_MSR_F_DDSR 0x00000002
+  #define UART_MSR_F_DDSR_OFFSET 1
+
+  /* Trailing Edge Ring Indicator.
+This bit indicates RI input to the chip has changed from low to high state since it was last read.
+Bit is cleared whenever the MSR is read. */ 
+  #define UART_MSR_F_TERI 0x00000004
+  #define UART_MSR_F_TERI_OFFSET 2
+
+  /* Delta Data Carrier Detect.
+This bit indicates DCD input has changed state since it was last read.
+Bit is cleared whenever the MSR is read. */ 
+  #define UART_MSR_F_DDCD 0x00000008
+  #define UART_MSR_F_DDCD_OFFSET 3
+
+  /* Clear To Send.
+This bit is ~CTS input. In loop-back mode this bit is equivalent of MCR[RTS].
+Bit is cleared whenever the MSR is read. */ 
+  #define UART_MSR_F_CTS 0x00000010
+  #define UART_MSR_F_CTS_OFFSET 4
+
+  /* Clear To Send.
+This bit is ~DSR input. In loop-back mode this bit is equivalent of MCR[DTR].
+Bit is cleared whenever the MSR is read. */ 
+  #define UART_MSR_F_DSR 0x00000020
+  #define UART_MSR_F_DSR_OFFSET 5
+
+  /* Ring Indicator.
+This bit is ~RI input. In loop-back mode this bit is equivalent of MCR[OUT1].
+Bit is cleared whenever the MSR is read. */ 
+  #define UART_MSR_F_RI 0x00000040
+  #define UART_MSR_F_RI_OFFSET 6
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_msr(void)
+{
+	return REG8(UART_MSR);
+}
+
+static inline void uart_write_msr(uint8_t value)
+{
+	REG8(UART_MSR) = value;
+}
+
+static inline uint8_t uart_rw_msr(uint8_t value)
+{
+	return rw_reg8(UART_MSR_PTR, value);
+}
+
+static inline uint8_t uart_set_msr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_MSR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_msr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_MSR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register SCR @ 0x10700007
+ *   (read-write 8-bit memory mapped register)
+ *   "SCRatchpad register.
+This register does not control UART operation. It can be used by programmer as temporary buffer."
+ *------------------------------------------------------------------
+ */
+#define UART_SCR 0x10700007
+#define UART_SCR_PTR (uint8_t *)(0x10700007)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_scr(void)
+{
+	return REG8(UART_SCR);
+}
+
+static inline void uart_write_scr(uint8_t value)
+{
+	REG8(UART_SCR) = value;
+}
+
+static inline uint8_t uart_rw_scr(uint8_t value)
+{
+	return rw_reg8(UART_SCR_PTR, value);
+}
+
+static inline uint8_t uart_set_scr(uint_csr32_t setmask)
+{
+	return set_reg8(UART_SCR_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_scr(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_SCR_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register DDLL @ 0x10700008
+ *   (read-only 8-bit memory mapped register)
+ *   "DLL (alias LSB-DL): divisor latch LSB. Defines bits [7:0] of divisor.
+This is DLL read only copy of register mirrored to directly accessible address (no DLAB manipulation required).
+It's value is always equal to DLL."
+ *------------------------------------------------------------------
+ */
+#define UART_DDLL 0x10700008
+#define UART_DDLL_PTR (uint8_t *)(0x10700008)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_ddll(void)
+{
+	return REG8(UART_DDLL);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register DDLM @ 0x10700009
+ *   (read-only 8-bit memory mapped register)
+ *   "DLM (alias MSB-DL): divisor latch MSB. Defines bits [15:8] of divisor.
+This is DLM read only copy of register mirrored to directly accessible address (no DLAB manipulation required).
+It's value is always equal to DLM."
+ *------------------------------------------------------------------
+ */
+#define UART_DDLM 0x10700009
+#define UART_DDLM_PTR (uint8_t *)(0x10700009)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_ddlm(void)
+{
+	return REG8(UART_DDLM);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register TxFFL @ 0x1070000a
+ *   (read-write 8-bit memory mapped register)
+ *   "Transmitter FIFO fill level"
+ *------------------------------------------------------------------
+ */
+#define UART_TXFFL 0x1070000a
+#define UART_TXFFL_PTR (uint8_t *)(0x1070000a)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_txffl(void)
+{
+	return REG8(UART_TXFFL);
+}
+
+static inline void uart_write_txffl(uint8_t value)
+{
+	REG8(UART_TXFFL) = value;
+}
+
+static inline uint8_t uart_rw_txffl(uint8_t value)
+{
+	return rw_reg8(UART_TXFFL_PTR, value);
+}
+
+static inline uint8_t uart_set_txffl(uint_csr32_t setmask)
+{
+	return set_reg8(UART_TXFFL_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_txffl(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_TXFFL_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register RxFFL @ 0x1070000b
+ *   (read-write 8-bit memory mapped register)
+ *   "Receiver FIFO fill level"
+ *------------------------------------------------------------------
+ */
+#define UART_RXFFL 0x1070000b
+#define UART_RXFFL_PTR (uint8_t *)(0x1070000b)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rxffl(void)
+{
+	return REG8(UART_RXFFL);
+}
+
+static inline void uart_write_rxffl(uint8_t value)
+{
+	REG8(UART_RXFFL) = value;
+}
+
+static inline uint8_t uart_rw_rxffl(uint8_t value)
+{
+	return rw_reg8(UART_RXFFL_PTR, value);
+}
+
+static inline uint8_t uart_set_rxffl(uint_csr32_t setmask)
+{
+	return set_reg8(UART_RXFFL_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_rxffl(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_RXFFL_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register rev0 @ 0x1070000c
+ *   (read-only 8-bit memory mapped register)
+ *   "bits 0:7 of UART revision"
+ *------------------------------------------------------------------
+ */
+#define UART_REV0 0x1070000c
+#define UART_REV0_PTR (uint8_t *)(0x1070000c)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rev0(void)
+{
+	return REG8(UART_REV0);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register rev1 @ 0x1070000d
+ *   (read-only 8-bit memory mapped register)
+ *   "bits 8:15 of UART revision"
+ *------------------------------------------------------------------
+ */
+#define UART_REV1 0x1070000d
+#define UART_REV1_PTR (uint8_t *)(0x1070000d)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rev1(void)
+{
+	return REG8(UART_REV1);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register rev2 @ 0x1070000e
+ *   (read-only 8-bit memory mapped register)
+ *   "bits 16:23 of UART revision"
+ *------------------------------------------------------------------
+ */
+#define UART_REV2 0x1070000e
+#define UART_REV2_PTR (uint8_t *)(0x1070000e)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rev2(void)
+{
+	return REG8(UART_REV2);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register rev3 @ 0x1070000f
+ *   (read-only 8-bit memory mapped register)
+ *   "bits 24:31 of UART revision"
+ *------------------------------------------------------------------
+ */
+#define UART_REV3 0x1070000f
+#define UART_REV3_PTR (uint8_t *)(0x1070000f)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_rev3(void)
+{
+	return REG8(UART_REV3);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register CLKDIVP_L @ 0x10700010
+ *   (read-write 8-bit memory mapped register)
+ *   "bits P[0:7] of P/Q divider numerator.
+Baud rate is generated by firstly dividing a CLK signal by ratio of [CLKDIVQ/CLKDIVP], 
+then by [DLM,DLL] and finally by 16.
+It is required that CLKDIVQ>=CLKDIVP."
+ *------------------------------------------------------------------
+ */
+#define UART_CLKDIVP_L 0x10700010
+#define UART_CLKDIVP_L_PTR (uint8_t *)(0x10700010)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_clkdivp_l(void)
+{
+	return REG8(UART_CLKDIVP_L);
+}
+
+static inline void uart_write_clkdivp_l(uint8_t value)
+{
+	REG8(UART_CLKDIVP_L) = value;
+}
+
+static inline uint8_t uart_rw_clkdivp_l(uint8_t value)
+{
+	return rw_reg8(UART_CLKDIVP_L_PTR, value);
+}
+
+static inline uint8_t uart_set_clkdivp_l(uint_csr32_t setmask)
+{
+	return set_reg8(UART_CLKDIVP_L_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_clkdivp_l(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_CLKDIVP_L_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register CLKDIVP_M @ 0x10700011
+ *   (read-write 8-bit memory mapped register)
+ *   "bits P[15:8] of P/Q divider numerator
+Baud rate is generated by firstly dividing a CLK signal by ratio of [CLKDIVQ/CLKDIVP], 
+then by [DLM,DLL] and finally by 16.
+It is required that CLKDIVQ>=CLKDIVP."
+ *------------------------------------------------------------------
+ */
+#define UART_CLKDIVP_M 0x10700011
+#define UART_CLKDIVP_M_PTR (uint8_t *)(0x10700011)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_clkdivp_m(void)
+{
+	return REG8(UART_CLKDIVP_M);
+}
+
+static inline void uart_write_clkdivp_m(uint8_t value)
+{
+	REG8(UART_CLKDIVP_M) = value;
+}
+
+static inline uint8_t uart_rw_clkdivp_m(uint8_t value)
+{
+	return rw_reg8(UART_CLKDIVP_M_PTR, value);
+}
+
+static inline uint8_t uart_set_clkdivp_m(uint_csr32_t setmask)
+{
+	return set_reg8(UART_CLKDIVP_M_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_clkdivp_m(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_CLKDIVP_M_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register CLKDIVQ_L @ 0x10700012
+ *   (read-write 8-bit memory mapped register)
+ *   "bits Q[0:7] of P/Q divider denominator
+Baud rate is generated by firstly dividing a CLK signal by ratio of [CLKDIVQ/CLKDIVP], 
+then by [DLM,DLL] and finally by 16.
+It is required that CLKDIVQ>=CLKDIVP."
+ *------------------------------------------------------------------
+ */
+#define UART_CLKDIVQ_L 0x10700012
+#define UART_CLKDIVQ_L_PTR (uint8_t *)(0x10700012)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_clkdivq_l(void)
+{
+	return REG8(UART_CLKDIVQ_L);
+}
+
+static inline void uart_write_clkdivq_l(uint8_t value)
+{
+	REG8(UART_CLKDIVQ_L) = value;
+}
+
+static inline uint8_t uart_rw_clkdivq_l(uint8_t value)
+{
+	return rw_reg8(UART_CLKDIVQ_L_PTR, value);
+}
+
+static inline uint8_t uart_set_clkdivq_l(uint_csr32_t setmask)
+{
+	return set_reg8(UART_CLKDIVQ_L_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_clkdivq_l(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_CLKDIVQ_L_PTR, clrmask);
+}
+#endif
+
+/*------------------------------------------------------------------
+ * register CLKDIVQ_M @ 0x10700013
+ *   (read-write 8-bit memory mapped register)
+ *   "bits Q[15:8] of P/Q divider denominator
+Baud rate is generated by firstly dividing a CLK signal by ratio of [CLKDIVQ/CLKDIVP], 
+then by [DLM,DLL] and finally by 16.
+It is required that CLKDIVQ>=CLKDIVP."
+ *------------------------------------------------------------------
+ */
+#define UART_CLKDIVQ_M 0x10700013
+#define UART_CLKDIVQ_M_PTR (uint8_t *)(0x10700013)
+
+
+#ifndef __ASSEMBLER__
+
+static inline uint8_t uart_read_clkdivq_m(void)
+{
+	return REG8(UART_CLKDIVQ_M);
+}
+
+static inline void uart_write_clkdivq_m(uint8_t value)
+{
+	REG8(UART_CLKDIVQ_M) = value;
+}
+
+static inline uint8_t uart_rw_clkdivq_m(uint8_t value)
+{
+	return rw_reg8(UART_CLKDIVQ_M_PTR, value);
+}
+
+static inline uint8_t uart_set_clkdivq_m(uint_csr32_t setmask)
+{
+	return set_reg8(UART_CLKDIVQ_M_PTR, setmask);
+}
+
+static inline uint8_t uart_clear_clkdivq_m(uint_csr32_t clrmask)
+{
+	return clear_reg8(UART_CLKDIVQ_M_PTR, clrmask);
+}
+#endif
+
+//-----------------------------------------------------------------------------
+// UART implementation of read & write character calls.
+//-----------------------------------------------------------------------------
+
+// Configuration
+const unsigned int CPU_CLK = 25000000;            /* CPU clockrate: 25MHz */
+const unsigned int MTIME_CLK = CPU_CLK;           /* mtimer ticks with same frequency as CPU clock */
+const unsigned int UART_CLK_IN = CPU_CLK;         /* Input UART clock (on bydahbsoc same as CPU clockrate) */
+const unsigned int UART_BAUD_RATE = 115200;       /* UART baudrate to select */
+
+static bool uart_initialized = false;       /* flag for automatic UART initialization */
+
+/**
+ * Initializes UART.
+ */
+void UART_Init(void)
+{
+	int divisor;
+
+	/* Reset receiver and transmitter, enable fifo... */
+	uart_write_fcr(VAL2REGFIELD(1, UART_FCR_F_FIFO_ENABLE) |
+	               VAL2REGFIELD(1, UART_FCR_F_RFR) |
+	               VAL2REGFIELD(1, UART_FCR_F_TFR) |
+	               VAL2REGFIELD(UART_FCR_F_RFTRIG_E_TL_7_8, UART_FCR_F_RFTRIG));
+
+	/* Disable all interrupts */
+	uart_write_ier(0x00);
+
+	/* Calculate and set baud rate */
+	divisor = UART_CLK_IN / (16 * UART_BAUD_RATE);
+	uart_write_lcr(UART_LCR_F_DLAB);
+	uart_write_dll(divisor & 0x000000ff);
+	uart_write_dlm((divisor >> 8) & 0x000000ff);
+
+	/* Set 8 bit char, 1 stop bit, no parity */
+	uart_write_lcr(VAL2REGFIELD(UART_LCR_F_BITS_E_CHR8B, UART_LCR_F_BITS) |
+	               VAL2REGFIELD(UART_LCR_F_STOP_E_STOP_1, UART_LCR_F_STOP) |
+	               VAL2REGFIELD(UART_LCR_F_PARITY_E_NO_PARITY, UART_LCR_F_PARITY));
+
+	uart_initialized = true;
+}
+
+/**
+ * Waits for transmitter hold register to empty.
+ * When it is empty, we can write more data.
+ */
+static void UART_WaitForTHRE(void)
+{
+	unsigned char lsr;
+	do {
+		lsr = uart_read_lsr();
+	} while (REGFIELD2VAL(lsr, UART_LSR_F_THRE) == 0);
+}
+
+/**
+ * Waits until "receiver data ready" is set.
+ * (Which means we can read character.)
+ */
+static void UART_WaitForData()
+{
+	unsigned char lsr;
+	do {
+		lsr = uart_read_lsr();
+	} while ((lsr & UART_LSR_F_DR) == 0);
+}
+
+/**
+ * Puts single character to UART.
+ * Waits until UART is ready to receive next character.
+ *
+ * @param c [in] character to send to UART
+ */
+static void UART_PutC(char c)
+{
+	if (!uart_initialized) UART_Init(); // make sure uart has been initialized
+
+	UART_WaitForTHRE();
+	uart_write_thr(c);
+}
+
+/**
+ * Gets single character for UART.
+ * (Waits until one is available)
+ *
+ * @return returns character received
+ */
+static char UART_GetC(void)
+{
+	if (!uart_initialized) UART_Init(); // make sure uart has been initialized
+
+	UART_WaitForData();
+	return uart_read_rbr();
+}
+
+// OpenSBI specific support
+
+static void beyond_cs_uart_putc(char ch)
+{
+    UART_PutC(ch);
+}
+
+static int beyond_cs_uart_getc(void)
+{
+    return UART_GetC();
+}
+
+static struct sbi_console_device beyond_cs_uart_console = {
+	.name = "xlnx-uartlite",
+	.console_putc = beyond_cs_uart_putc,
+	.console_getc = beyond_cs_uart_getc
+};
+
+int beyond_cs_uart_init()
+{
+    UART_Init();
+	sbi_console_set_device(&beyond_cs_uart_console);
+	return 0;
+}
+
+
+#endif // __regaccess_Beyond_Semiconductor_BA5x_BydAHBSOC_1_0_UART__
+
diff --git a/include/sbi_utils/serial/rvrac.h b/include/sbi_utils/serial/rvrac.h
new file mode 100644
index 0000000..5c0f5ec
--- /dev/null
+++ b/include/sbi_utils/serial/rvrac.h
@@ -0,0 +1,307 @@
+/**
+ * Generic CSR & memory mapped register access macros & functions
+ *   for risc-v.
+ */
+
+#ifndef _BEYOND_RVRAC_H_
+#define _BEYOND_RVRAC_H_
+
+#ifndef __ASSEMBLER__
+//#include <stdint.h>
+#endif
+
+#if __riscv_xlen==32
+
+#ifndef __ASSEMBLER__
+typedef uint32_t uint_xlen_t;
+typedef uint32_t uint_csr32_t;
+#endif
+
+#else
+
+// this header only supports RV32
+#error "unsupported XLEN"
+
+#endif
+
+// ============================================================================
+// Generic helper macros & functions
+// ============================================================================
+
+/**
+ * Masks out other bits of register value "val" except those belonging to
+ * filed "fld".
+ *   @param val retister value
+ *   @param fld field name
+ * 
+ * example: MASKREGFIELD(x, CSR_MSTATUS_F_VS)
+ *   the above will zero out all bits extept VS
+ */
+#define MASKREGFIELD(val, fld) ((val) & (fld))
+
+/**
+ * Shifts value from bit positions [n:0] to its position within register 
+ * and masks away bits that are not part of chosen field.
+ *   @param val value to shif
+ *   @param fld name of field
+ * 
+ * example: VAL2REGFIELD(CSR_MSTATUS_F_VS_E_INITIAL, CSR_MSTATUS_F_VS)
+ */
+#define VAL2REGFIELD(val, fld) MASKREGFIELD((val << fld##_OFFSET), (fld))
+
+/**
+ * Shifts register field to bit positions [n:0] and masks away bits that
+ * are not part of chosen field.
+ *   @param val 
+ */
+#define REGFIELD2VAL(val, fld) (MASKREGFIELD(val, fld) >> fld##_OFFSET)
+
+//watchdog_timer_MODE_F_ENABLE
+
+// ============================================================================
+// CSR registers
+// ============================================================================
+
+/**
+ * Returns value of CSR register #csrno
+ */
+#define READ_CSRNO(csrno) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrr %0 , %1" : "=r"(__rv) : "n"(csrno)); \
+	__rv; \
+})
+
+/**
+ * Returns value of CSR register named "csr"
+ */
+#define READ_CSR(csr) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrr %0 ," #csr : "=r"(__rv)); \
+	__rv; \
+})
+
+/**
+ * Sets value of CSR register #csrno to value val.
+ */
+#define WRITE_CSRNO(csrno, val) ({ \
+	asm volatile ("csrw %0, %1" :: "I"(csrno), "rK"(val)); \
+})
+
+/**
+ * Sets value of CSR register named "csr" to value val.
+ */
+#define WRITE_CSR(csr, val) ({ \
+  asm volatile ("csrw " #csr ", 0" :: "rK"(val)); \
+})
+
+/**
+ * Sets value of CSR register #csrno to value val and
+ * returns previous value of same CSR register.
+ */
+#define RW_CSRNO(csrno, val) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrw %0, %1, %2" : "=r"(__rv) : "I"(csrno), "rK"(val)); \
+	__rv; \
+})
+
+/**
+ * Sets value of CSR register "csr" to value val and
+ * returns previous value of same CSR register.
+ */
+#define RW_CSR(csr, val) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrw %0, " #csr ", %1" : "=r"(__rv) : "rK"(val)); \
+	__rv; \
+})
+
+/**
+ * Sets all bits that are set in "setmask" to 1 in CSR register #csrno.
+ * Return previous value of same CSR register.
+ */
+#define SET_CSRNO(csrno, setmask) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrs %0, %1, %2" : "=r"(__rv) : "I"(csrno), "rK"(setmask)); \
+	__rv; \
+})
+
+/**
+ * Sets all bits that are set in "setmask" to 1 in CSR register "csr".
+ * Return previous value of same CSR register.
+ */
+#define SET_CSR(csr, setmask) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrs %0, " #csr ", %1" : "=r"(__rv) : "rK"(setmask)); \
+	__rv; \
+})
+
+/**
+ * Clears all bits that are set in "setmask" to 1 in CSR register #csrno.
+ * Return previous value of same CSR register.
+ */
+#define CLEAR_CSRNO(csrno, clrmask) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrc %0, %1, %2" : "=r"(__rv) : "I"(csrno), "rK"(clrmask)); \
+	__rv; \
+})
+
+/**
+ * Clears all bits that are set in "setmask" to 1 in CSR register "csr".
+ * Return previous value of same CSR register.
+ */
+#define CLEAR_CSR(csr, clrmask) ({ \
+	uint_csr32_t __rv; \
+	asm volatile ("csrrc %0, " #csr ", %1" : "=r"(__rv) : "rK"(clrmask)); \
+	__rv; \
+})
+
+// ============================================================================
+// Memory mapped registers
+// ============================================================================
+
+/* Register access macros */
+
+#define REG8(addr) *((volatile uint8_t *)(addr))
+#define REG16(addr) *((volatile uint16_t *)(addr))
+#define REG32(addr) *((volatile uint32_t *)(addr))
+#define REG64(addr) *((volatile uint64_t *)(addr))
+
+#ifndef __ASSEMBLER__
+
+/**
+ * Access functions follow this naming pattern:
+ *
+ *   peripheral_read_registername()
+ *     This function reads and returns value of register.
+ *   peripheral_write_registername(value)
+ *     This function writes new value to a register.
+ *   peripheral_rw_registername(value)
+ *     Writes new value to register and returns previous value. Implementation
+ *     might be atomic or not (see comments below)
+ *   peripheral_set_registername(omask)
+ *     Reads value of register, ors it with omask and writes or-ed value back.
+ *     (Effectively sets bits set in omask. Might be atomic.)
+ *   peripheral_clear_registername(cmask)
+ *     Reads value of register, ands it with ~cmask and writes and-ed value back.
+ *     (Effectively clears bits set in omask. Might be atomic.)
+ */
+
+#if __riscv_atomic
+
+/*
+ * Atomic rw/set/clear implementations are only available for 32-bit registers
+ * and only if atomic instruction set is supported on target.
+ * In all other cases rw/set/clear functions are not atomic.
+ */
+__attribute__((unused))
+static inline uint32_t rw_reg32(uint32_t *mad, uint32_t nv)
+{
+	uint32_t result;
+	asm volatile ("amoswap.w %0, %2, %1" : "=r"(result), "+A"(*mad) : "r" (nv));
+	return result;
+}
+
+__attribute__((unused))
+static inline uint32_t set_reg32(uint32_t *mad, uint32_t omask)
+{
+	uint32_t result;
+	asm volatile ("amoor.w %0, %2, %1" : "=r"(result), "+A"(*mad) : "r" (omask));
+	return result;
+}
+
+__attribute__((unused))
+static inline uint32_t clear_reg32(uint32_t *mad, uint32_t amask)
+{
+	uint32_t result;
+	asm volatile ("amoand.w %0, %2, %1" : "=r"(result), "+A"(*mad) : "r" (~amask));
+	return result;
+}
+#else
+
+// non-atomic 32-bit rw/set/clear
+
+__attribute__((unused))
+static inline uint32_t rw_reg32(uint32_t *mad, uint32_t nv)
+{
+	uint32_t result;
+	result = REG32(mad);
+	REG32(mad) = nv;
+	return result;
+}
+
+__attribute__((unused))
+static inline uint32_t set_reg32(uint32_t *mad, uint32_t omask)
+{
+	uint32_t result;
+	result = REG32(mad);
+	REG32(mad) = (result | omask);
+	return result;
+}
+
+__attribute__((unused))
+static inline uint32_t clear_reg32(uint32_t *mad, uint32_t amask)
+{
+	uint32_t result;
+	result = REG32(mad);
+	REG32(mad) = (result & ~amask);
+	return result;
+}
+
+#endif
+
+__attribute__((unused))
+static inline uint16_t rw_reg16(uint16_t *mad, uint16_t nv)
+{
+	uint16_t result;
+	result = REG16(mad);
+	REG16(mad) = nv;
+	return result;
+}
+
+__attribute__((unused))
+static inline uint16_t set_reg16(uint16_t *mad, uint16_t omask)
+{
+	uint16_t result;
+	result = REG16(mad);
+	REG16(mad) = (result | omask);
+	return result;
+}
+
+__attribute__((unused))
+static inline uint16_t clear_reg16(uint16_t *mad, uint16_t amask)
+{
+	uint16_t result;
+	result = REG16(mad);
+	REG16(mad) = (result & ~amask);
+	return result;
+}
+
+__attribute__((unused))
+static inline uint8_t rw_reg8(uint8_t *mad, uint8_t nv)
+{
+	uint8_t result;
+	result = REG8(mad);
+	REG8(mad) = nv;
+	return result;
+}
+
+__attribute__((unused))
+static inline uint8_t set_reg8(uint8_t *mad, uint8_t omask)
+{
+	uint8_t result;
+	result = REG8(mad);
+	REG8(mad) = (result | omask);
+	return result;
+}
+
+__attribute__((unused))
+static inline uint8_t clear_reg8(uint8_t *mad, uint8_t amask)
+{
+	uint8_t result;
+	result = REG8(mad);
+	REG8(mad) = (result & ~amask);
+	return result;
+}
+
+#endif
+
+#endif /* _BEYOND_RVRAC_H_ */
diff --git a/platform/beyond/ba51_cs/Kconfig b/platform/beyond/ba51_cs/Kconfig
new file mode 100644
index 0000000..6bc838a
--- /dev/null
+++ b/platform/beyond/ba51_cs/Kconfig
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: BSD-2-Clause
+
+#
+# All mandatory drivers or libraries for this platform should
+# be directly selected by the PLATFORM_xyz kconfig symbol.
+#
+# All optional drivers or libraries for this platform should
+# be enabled via configs/defconfig of this platform.
+#
+config PLATFORM_BEYOND_BA51_CS
+	bool
+	select IPI_MSWI
+	#select IRQCHIP_APLIC
+	select SERIAL_BEYOND_CS_SIM
+	select TIMER_MTIMER
+	default y
diff --git a/platform/beyond/ba51_cs/configs/defconfig b/platform/beyond/ba51_cs/configs/defconfig
new file mode 100644
index 0000000..139597f
--- /dev/null
+++ b/platform/beyond/ba51_cs/configs/defconfig
@@ -0,0 +1,2 @@
+
+
diff --git a/platform/beyond/ba51_cs/objects.mk b/platform/beyond/ba51_cs/objects.mk
new file mode 100644
index 0000000..022ae64
--- /dev/null
+++ b/platform/beyond/ba51_cs/objects.mk
@@ -0,0 +1,88 @@
+#
+# SPDX-License-Identifier: BSD-2-Clause
+#
+# Copyright (c) 2019 Western Digital Corporation or its affiliates.
+#
+
+# Compiler pre-processor flags
+platform-cppflags-y = -Os
+
+# C Compiler and assembler flags.
+platform-cflags-y =
+platform-asflags-y =
+
+# Linker flags: additional libraries and object files that the platform
+# code needs can be added here
+platform-ldflags-y =
+
+#
+# Command for platform specific "make run"
+# Useful for development and debugging on plaftform simulator (such as QEMU)
+#
+# platform-runcmd = your_platform_run.sh
+
+#
+# Platform RISC-V XLEN, ABI, ISA and Code Model configuration.
+# These are optional parameters but platforms can optionaly provide it.
+# Some of these are guessed based on GCC compiler capabilities
+#
+PLATFORM_RISCV_XLEN = 32
+PLATFORM_RISCV_ISA = rv32imac_zca_zcb_zcf_zifencei
+PLATFORM_RISCV_ABI = ilp32
+
+# Space separated list of object file names to be compiled for the platform
+platform-objs-y += platform.o
+
+#
+# If the platform support requires a builtin device tree file, the name of
+# the device tree compiled file should be specified here. The device tree
+# source file be in the form <dt file name>.dts
+#
+# platform-objs-y += <dt file name>.
+
+# Firmware load address configuration. This is mandatory.
+FW_TEXT_START=0x00000000
+
+# Optional parameter for path to external FDT
+# FW_FDT_PATH="path to platform flattened device tree file"
+
+#
+# Dynamic firmware configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_DYNAMIC=y
+
+#
+# Jump firmware configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_JUMP=n
+# This needs to be 4MB aligned for 32-bit support
+# This needs to be 2MB aligned for 64-bit support
+#ifeq ($(PLATFORM_RISCV_XLEN), 32)
+#FW_JUMP_ADDR=0x00400000
+#else
+#FW_JUMP_ADDR=0x80200000
+#endif
+#FW_JUMP_FDT_ADDR=0x82200000
+
+#
+# Firmware with payload configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_PAYLOAD=y
+# This needs to be 4MB aligned for 32-bit support
+# This needs to be 2MB aligned for 64-bit support
+#ifeq ($(PLATFORM_RISCV_XLEN), 32)
+#FW_PAYLOAD_OFFSET=0x400000
+#FW_PAYLOAD_OFFSET=0x40000
+FW_PAYLOAD_OFFSET=0x30000
+#else
+#FW_PAYLOAD_OFFSET=0x200000
+#endif
+FW_PAYLOAD_ALIGN=0x1000
+# FW_PAYLOAD_PATH="path to next boot stage binary image file"
+# FW_PAYLOAD_FDT_ADDR=0x82200000
diff --git a/platform/beyond/ba51_cs/platform.c b/platform/beyond/ba51_cs/platform.c
new file mode 100644
index 0000000..9eb88e4
--- /dev/null
+++ b/platform/beyond/ba51_cs/platform.c
@@ -0,0 +1,229 @@
+/*
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) 2019 Western Digital Corporation or its affiliates.
+ */
+
+#include <sbi/riscv_asm.h>
+#include <sbi/riscv_encoding.h>
+#include <sbi/sbi_const.h>
+#include <sbi/sbi_platform.h>
+
+/*
+ * Include these files as needed.
+ * See objects.mk BEYOND_BA51_xxx configuration parameters.
+ */
+#include <sbi_utils/ipi/aclint_mswi.h>
+#include <sbi_utils/irqchip/aplic.h>
+#include <sbi_utils/serial/beyond_cs_uart.h>
+#include <sbi_utils/timer/aclint_mtimer.h>
+
+#define UART_ADDR 0x10700000
+
+#define BEYOND_BA51_HART_COUNT          1
+
+#define BEYOND_BA51_APLIC_ADDR          0x0c000000
+#define BEYOND_BA51_APLIC_SIZE          (0x00200000 + (BEYOND_BA51_HART_COUNT * 0x00001000))
+#define BEYOND_BA51_APLIC_NUM_IDC       1
+#define BEYOND_BA51_APLIC_NUM_SOURCES   32
+
+#define BEYOND_BA51_CLINT_ADDR          0x02000000
+#define BEYOND_BA51_ACLINT_MTIMER_FREQ  10000000
+#define BEYOND_BA51_ACLINT_MSWI_ADDR    (BEYOND_BA51_CLINT_ADDR + CLINT_MSWI_OFFSET)
+#define BEYOND_BA51_ACLINT_MTIMER_ADDR  (BEYOND_BA51_CLINT_ADDR + CLINT_MTIMER_OFFSET)
+
+#define PG_ADD_SIG_DRV_ADR 0x23100000
+#define APB_SUB_PG_CSR_ADR 0x23300000
+
+// PG restricted address range mode: register information
+
+#define PG_RAS_NUM_OF_RANGES 8
+#define PG_RAS_ADDR_FIRST_REG_ADDR 0x10
+#define PG_RAS_ACC_PRM_FIRST_REG_ADDR (PG_RAS_ADDR_FIRST_REG_ADDR + PG_RAS_NUM_OF_RANGES + 1)
+                                                                                
+#define PG_RAS_ACC_PRM_REG_R_BIT 0
+#define PG_RAS_ACC_PRM_REG_W_BIT 1
+#define PG_RAS_ACC_PRM_REG_DID_SIZE 29
+#define PG_RAS_ACC_PRM_REG_DID_LOW 2
+#define PG_RAS_ACC_PRM_REG_DID_HIGH (PG_RAS_ACC_PRM_REG_DID_LOW + PG_RAS_ACC_PRM_REG_DID_SIZE)
+#define PG_RAS_ACC_PRM_REG_A_BIT 31
+
+
+
+//#define BEYOND_BA51_UART_ADDR           0x10700000
+//#define BEYOND_BA51_UART_INPUT_FREQ     10000000
+//#define BEYOND_BA51_UART_BAUDRATE       115200
+
+//static struct plic_data plic = {
+//    .addr = BEYOND_BA51_APLIC_ADDR,
+//    .size = BEYOND_BA51_APLIC_SIZE,
+//    .num_src = BEYOND_BA51_APLIC_NUM_SOURCES,
+//};
+
+//static struct aplic_data aplic = {
+//	.addr = BEYOND_BA51_APLIC_ADDR,
+//	.size = BEYOND_BA51_APLIC_SIZE,
+//	.num_idc = BEYOND_BA51_APLIC_NUM_IDC,
+//	.num_source = BEYOND_BA51_APLIC_NUM_SOURCES,
+//	.targets_mmode = false,
+//	.has_msicfg_mmode = false,
+//	//struct aplic_msicfg_data msicfg_mmode;
+//	.has_msicfg_smode = false
+//	//struct aplic_msicfg_data msicfg_smode;
+//	//struct aplic_delegate_data delegate[APLIC_MAX_DELEGATE];
+//};
+
+static struct aclint_mswi_data mswi = {
+    .addr = BEYOND_BA51_ACLINT_MSWI_ADDR,
+    .size = ACLINT_MSWI_SIZE,
+    .first_hartid = 0,
+    .hart_count = BEYOND_BA51_HART_COUNT,
+};
+
+static struct aclint_mtimer_data mtimer = {
+    .mtime_freq = BEYOND_BA51_ACLINT_MTIMER_FREQ,
+    .mtime_addr = BEYOND_BA51_ACLINT_MTIMER_ADDR +
+                  ACLINT_DEFAULT_MTIME_OFFSET,
+    .mtime_size = ACLINT_DEFAULT_MTIME_SIZE,
+    .mtimecmp_addr = BEYOND_BA51_ACLINT_MTIMER_ADDR +
+                     ACLINT_DEFAULT_MTIMECMP_OFFSET,
+    .mtimecmp_size = ACLINT_DEFAULT_MTIMECMP_SIZE,
+    .first_hartid = 0,
+    .hart_count = BEYOND_BA51_HART_COUNT,
+    .has_64bit_mmio = true,
+};
+
+// Set PG's address range entry for restricted address space mode.
+void set_pg_rspace_entry(
+    uint32_t* pg_csrs_base,
+    uint8_t entry,
+    uint8_t did,
+    uint32_t from_addr,
+    uint32_t to_addr,
+    bool allow_read,
+    bool allow_write)
+{
+    pg_csrs_base[PG_RAS_ADDR_FIRST_REG_ADDR + entry] = from_addr;
+    pg_csrs_base[PG_RAS_ADDR_FIRST_REG_ADDR + entry + 1] = to_addr;
+    pg_csrs_base[PG_RAS_ACC_PRM_FIRST_REG_ADDR + entry] = (uint32_t) (
+        (1 << PG_RAS_ACC_PRM_REG_A_BIT) |
+        (did << PG_RAS_ACC_PRM_REG_DID_LOW) |
+        (allow_read << PG_RAS_ACC_PRM_REG_R_BIT) |
+        (allow_write << PG_RAS_ACC_PRM_REG_W_BIT));
+}
+
+/*
+ * Platform early initialization.
+ */
+static int beyond_ba51_early_init(bool cold_boot)
+{
+
+    // Enable wfi instruction wake up on timer and external interrupts.
+    __asm__ volatile ("csrw 0x7c0, 0x3"); 
+
+    // Set domain to 0.
+    uint32_t *pg_add_sig_drv = (uint32_t*) PG_ADD_SIG_DRV_ADR;
+    pg_add_sig_drv[0] = 0;
+
+    // Configure APB subsystem's PG to allow access to UART to domain 0.
+    uint32_t *apb_sub_pg_csrs = (uint32_t*) APB_SUB_PG_CSR_ADR;
+    set_pg_rspace_entry(apb_sub_pg_csrs, 0, 0, UART_ADDR, UART_ADDR + 0xfffff, true, true);
+
+    return 0;
+}
+
+/*
+ * Platform final initialization.
+ */
+static int beyond_ba51_final_init(bool cold_boot)
+{
+    return 0;
+}
+
+/*
+ * Initialize the platform console.
+ */
+static int beyond_ba51_console_init(void)
+{
+    return beyond_cs_uart_init();
+}
+
+/*
+ * Initialize the platform interrupt controller for current HART.
+ */
+static int beyond_ba51_irqchip_init(bool cold_boot)
+{
+    ////u32 hartid = current_hartid();
+    //int ret;
+
+    ///* Example if the generic APLIC driver is used */
+    //if (cold_boot) {
+    //    //ret = plic_cold_irqchip_init(&plic);
+    //    ret = aplic_cold_irqchip_init(&aplic);
+    //    if (ret)
+    //        return ret;
+    //}
+
+    //return plic_warm_irqchip_init(&plic, 2 * hartid, 2 * hartid + 1);
+    return 0;
+}
+
+/*
+ * Initialize IPI for current HART.
+ */
+static int beyond_ba51_ipi_init(bool cold_boot)
+{
+    int ret;
+
+    /* Example if the generic ACLINT driver is used */
+    if (cold_boot) {
+        ret = aclint_mswi_cold_init(&mswi);
+        if (ret)
+            return ret;
+    }
+
+    return aclint_mswi_warm_init();
+}
+
+/*
+ * Initialize platform timer for current HART.
+ */
+static int beyond_ba51_timer_init(bool cold_boot)
+{
+    int ret;
+
+    /* Example if the generic ACLINT driver is used */
+    if (cold_boot) {
+        ret = aclint_mtimer_cold_init(&mtimer, NULL);
+        if (ret)
+            return ret;
+    }
+
+    return aclint_mtimer_warm_init();
+}
+
+/*
+ * Platform descriptor.
+ */
+const struct sbi_platform_operations beyond_ba51_ops = {
+    .early_init         = beyond_ba51_early_init,
+    .final_init         = beyond_ba51_final_init,
+    .console_init       = beyond_ba51_console_init,
+    .irqchip_init       = beyond_ba51_irqchip_init,
+    .ipi_init           = beyond_ba51_ipi_init,
+    .timer_init         = beyond_ba51_timer_init
+};
+
+#define HART_STACK_SIZE 0x1000
+#define HEAP_SIZE(__num_hart) (0x4000 + 0x400 * (__num_hart))
+
+const struct sbi_platform platform = {
+    .opensbi_version    = OPENSBI_VERSION,
+    .platform_version   = SBI_PLATFORM_VERSION(0x0, 0x00),
+    .name               = "Beyond BA51",
+    .features           = SBI_PLATFORM_DEFAULT_FEATURES,
+    .hart_count         = BEYOND_BA51_HART_COUNT,
+    .hart_stack_size    = HART_STACK_SIZE,
+    .heap_size          = HEAP_SIZE(BEYOND_BA51_HART_COUNT),
+    .platform_ops_addr  = (unsigned long)&beyond_ba51_ops
+};
diff --git a/platform/beyond/ba51_sim/Kconfig b/platform/beyond/ba51_sim/Kconfig
new file mode 100644
index 0000000..a9e98f7
--- /dev/null
+++ b/platform/beyond/ba51_sim/Kconfig
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: BSD-2-Clause
+
+#
+# All mandatory drivers or libraries for this platform should
+# be directly selected by the PLATFORM_xyz kconfig symbol.
+#
+# All optional drivers or libraries for this platform should
+# be enabled via configs/defconfig of this platform.
+#
+config PLATFORM_BEYOND_BA51_SIM
+	bool
+	select IPI_MSWI
+	#select IRQCHIP_APLIC
+	select SERIAL_BEYOND_SIMUART
+	select TIMER_MTIMER
+	default y
diff --git a/platform/beyond/ba51_sim/objects.mk b/platform/beyond/ba51_sim/objects.mk
new file mode 100644
index 0000000..c30bfb9
--- /dev/null
+++ b/platform/beyond/ba51_sim/objects.mk
@@ -0,0 +1,87 @@
+#
+# SPDX-License-Identifier: BSD-2-Clause
+#
+# Copyright (c) 2019 Western Digital Corporation or its affiliates.
+#
+
+# Compiler pre-processor flags
+platform-cppflags-y =
+
+# C Compiler and assembler flags.
+platform-cflags-y =
+platform-asflags-y =
+
+# Linker flags: additional libraries and object files that the platform
+# code needs can be added here
+platform-ldflags-y =
+
+#
+# Command for platform specific "make run"
+# Useful for development and debugging on plaftform simulator (such as QEMU)
+#
+# platform-runcmd = your_platform_run.sh
+
+#
+# Platform RISC-V XLEN, ABI, ISA and Code Model configuration.
+# These are optional parameters but platforms can optionaly provide it.
+# Some of these are guessed based on GCC compiler capabilities
+#
+# PLATFORM_RISCV_XLEN = 64
+# PLATFORM_RISCV_ABI = lp64
+# PLATFORM_RISCV_ISA = rv64imafdc
+# PLATFORM_RISCV_CODE_MODEL = medany
+
+# Space separated list of object file names to be compiled for the platform
+platform-objs-y += platform.o
+
+#
+# If the platform support requires a builtin device tree file, the name of
+# the device tree compiled file should be specified here. The device tree
+# source file be in the form <dt file name>.dts
+#
+# platform-objs-y += <dt file name>.o
+
+# Firmware load address configuration. This is mandatory.
+FW_TEXT_START=0x80000000
+
+# Optional parameter for path to external FDT
+# FW_FDT_PATH="path to platform flattened device tree file"
+
+#
+# Dynamic firmware configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_DYNAMIC=y
+
+#
+# Jump firmware configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_JUMP=y
+# This needs to be 4MB aligned for 32-bit support
+# This needs to be 2MB aligned for 64-bit support
+#ifeq ($(PLATFORM_RISCV_XLEN), 32)
+FW_JUMP_ADDR=0x80400000
+#else
+#FW_JUMP_ADDR=0x80200000
+#endif
+#FW_JUMP_FDT_ADDR=0x82200000
+
+#
+# Firmware with payload configuration.
+# Optional parameters are commented out. Uncomment and define these parameters
+# as needed.
+#
+FW_PAYLOAD=y
+# This needs to be 4MB aligned for 32-bit support
+# This needs to be 2MB aligned for 64-bit support
+#ifeq ($(PLATFORM_RISCV_XLEN), 32)
+FW_PAYLOAD_OFFSET=0x400000
+#else
+#FW_PAYLOAD_OFFSET=0x200000
+#endif
+FW_PAYLOAD_ALIGN=0x1000
+# FW_PAYLOAD_PATH="path to next boot stage binary image file"
+# FW_PAYLOAD_FDT_ADDR=0x82200000
diff --git a/platform/beyond/ba51_sim/platform.c b/platform/beyond/ba51_sim/platform.c
new file mode 100644
index 0000000..622597f
--- /dev/null
+++ b/platform/beyond/ba51_sim/platform.c
@@ -0,0 +1,176 @@
+/*
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) 2019 Western Digital Corporation or its affiliates.
+ */
+
+#include <sbi/riscv_asm.h>
+#include <sbi/riscv_encoding.h>
+#include <sbi/sbi_const.h>
+#include <sbi/sbi_platform.h>
+
+/*
+ * Include these files as needed.
+ * See objects.mk BEYOND_BA51_xxx configuration parameters.
+ */
+#include <sbi_utils/ipi/aclint_mswi.h>
+#include <sbi_utils/irqchip/aplic.h>
+#include <sbi_utils/serial/beyond_simuart.h>
+#include <sbi_utils/timer/aclint_mtimer.h>
+
+#define BEYOND_BA51_HART_COUNT          1
+
+#define BEYOND_BA51_APLIC_ADDR          0x0c000000
+#define BEYOND_BA51_APLIC_SIZE          (0x00200000 + (BEYOND_BA51_HART_COUNT * 0x00001000))
+#define BEYOND_BA51_APLIC_NUM_IDC       1
+#define BEYOND_BA51_APLIC_NUM_SOURCES   32
+
+#define BEYOND_BA51_CLINT_ADDR          0x02000000
+#define BEYOND_BA51_ACLINT_MTIMER_FREQ  10000000
+#define BEYOND_BA51_ACLINT_MSWI_ADDR    (BEYOND_BA51_CLINT_ADDR + CLINT_MSWI_OFFSET)
+#define BEYOND_BA51_ACLINT_MTIMER_ADDR  (BEYOND_BA51_CLINT_ADDR + CLINT_MTIMER_OFFSET)
+
+#define BEYOND_BA51_UART_ADDR           0x10700000
+#define BEYOND_BA51_UART_INPUT_FREQ     10000000
+#define BEYOND_BA51_UART_BAUDRATE       115200
+
+//static struct plic_data plic = {
+//    .addr = BEYOND_BA51_APLIC_ADDR,
+//    .size = BEYOND_BA51_APLIC_SIZE,
+//    .num_src = BEYOND_BA51_APLIC_NUM_SOURCES,
+//};
+
+//static struct aplic_data aplic = {
+//	.addr = BEYOND_BA51_APLIC_ADDR,
+//	.size = BEYOND_BA51_APLIC_SIZE,
+//	.num_idc = BEYOND_BA51_APLIC_NUM_IDC,
+//	.num_source = BEYOND_BA51_APLIC_NUM_SOURCES,
+//	.targets_mmode = false,
+//	.has_msicfg_mmode = false,
+//	//struct aplic_msicfg_data msicfg_mmode;
+//	.has_msicfg_smode = false
+//	//struct aplic_msicfg_data msicfg_smode;
+//	//struct aplic_delegate_data delegate[APLIC_MAX_DELEGATE];
+//};
+
+static struct aclint_mswi_data mswi = {
+    .addr = BEYOND_BA51_ACLINT_MSWI_ADDR,
+    .size = ACLINT_MSWI_SIZE,
+    .first_hartid = 0,
+    .hart_count = BEYOND_BA51_HART_COUNT,
+};
+
+static struct aclint_mtimer_data mtimer = {
+    .mtime_freq = BEYOND_BA51_ACLINT_MTIMER_FREQ,
+    .mtime_addr = BEYOND_BA51_ACLINT_MTIMER_ADDR +
+                  ACLINT_DEFAULT_MTIME_OFFSET,
+    .mtime_size = ACLINT_DEFAULT_MTIME_SIZE,
+    .mtimecmp_addr = BEYOND_BA51_ACLINT_MTIMER_ADDR +
+                     ACLINT_DEFAULT_MTIMECMP_OFFSET,
+    .mtimecmp_size = ACLINT_DEFAULT_MTIMECMP_SIZE,
+    .first_hartid = 0,
+    .hart_count = BEYOND_BA51_HART_COUNT,
+    .has_64bit_mmio = true,
+};
+
+/*
+ * Platform early initialization.
+ */
+static int beyond_ba51_early_init(bool cold_boot)
+{
+    return 0;
+}
+
+/*
+ * Platform final initialization.
+ */
+static int beyond_ba51_final_init(bool cold_boot)
+{
+    return 0;
+}
+
+/*
+ * Initialize the platform console.
+ */
+static int beyond_ba51_console_init(void)
+{
+    /* Example if the generic UART8250 driver is used */
+    return beyond_simuart_init(BEYOND_BA51_UART_ADDR);
+}
+
+/*
+ * Initialize the platform interrupt controller for current HART.
+ */
+static int beyond_ba51_irqchip_init(bool cold_boot)
+{
+    ////u32 hartid = current_hartid();
+    //int ret;
+
+    ///* Example if the generic APLIC driver is used */
+    //if (cold_boot) {
+    //    //ret = plic_cold_irqchip_init(&plic);
+    //    ret = aplic_cold_irqchip_init(&aplic);
+    //    if (ret)
+    //        return ret;
+    //}
+
+    //return plic_warm_irqchip_init(&plic, 2 * hartid, 2 * hartid + 1);
+    return 0;
+}
+
+/*
+ * Initialize IPI for current HART.
+ */
+static int beyond_ba51_ipi_init(bool cold_boot)
+{
+    int ret;
+
+    /* Example if the generic ACLINT driver is used */
+    if (cold_boot) {
+        ret = aclint_mswi_cold_init(&mswi);
+        if (ret)
+            return ret;
+    }
+
+    return aclint_mswi_warm_init();
+}
+
+/*
+ * Initialize platform timer for current HART.
+ */
+static int beyond_ba51_timer_init(bool cold_boot)
+{
+    int ret;
+
+    /* Example if the generic ACLINT driver is used */
+    if (cold_boot) {
+        ret = aclint_mtimer_cold_init(&mtimer, NULL);
+        if (ret)
+            return ret;
+    }
+
+    return aclint_mtimer_warm_init();
+}
+
+/*
+ * Platform descriptor.
+ */
+const struct sbi_platform_operations beyond_ba51_ops = {
+    .early_init         = beyond_ba51_early_init,
+    .final_init         = beyond_ba51_final_init,
+    .console_init       = beyond_ba51_console_init,
+    .irqchip_init       = beyond_ba51_irqchip_init,
+    .ipi_init           = beyond_ba51_ipi_init,
+    .timer_init         = beyond_ba51_timer_init
+};
+
+const struct sbi_platform platform = {
+    .opensbi_version    = OPENSBI_VERSION,
+    .platform_version   = SBI_PLATFORM_VERSION(0x0, 0x00),
+    .name               = "Beyond BA51",
+    .features           = SBI_PLATFORM_DEFAULT_FEATURES,
+    .hart_count         = BEYOND_BA51_HART_COUNT,
+    .hart_stack_size    = SBI_PLATFORM_DEFAULT_HART_STACK_SIZE,
+    .heap_size          = SBI_PLATFORM_DEFAULT_HEAP_SIZE(BEYOND_BA51_HART_COUNT),
+    .platform_ops_addr  = (unsigned long)&beyond_ba51_ops
+};
